"use strict";

var _objectWithoutProperties = function (obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var InputPopupWrapper = require("./InputPopupWrapper");
var ListKeyBindings = require("./ListKeyBindings");
var ListPopup = require("./ListPopup");
var React = require("react/addons");
var TypeaheadInput = require("./TypeaheadInput");

var PureRenderMixin = React.addons.PureRenderMixin;

var emptyFunction = require("./helpers/emptyFunction");
var getUniqueId = require("./helpers/getUniqueId");

/**
 * <Combobox> is a combobox-style widget that supports both inline- and 
 * menu-based autocompletion based on an asynchonously-loaded result set.
 */
var Combobox = React.createClass({
  displayName: "Combobox",

  mixins: [PureRenderMixin],

  propTypes: {
    /**
     * A function that fetches the autocomplete options for typed user input.
     * It takes the `value` of the <input>, and returns a promise that resolves
     * with an array of autocomplete options.
     */
    getOptionsForInputValue: React.PropTypes.func.isRequired,

    /**
     * Event handler fired when the `value` of the component changes.
     * Function called is passed `value`.
     */
    onChange: React.PropTypes.func.isRequired,

    /**
     * An object for the current value of the <Combobox> with two properties:
     *   - `inputValue`, the text that the user entered into the <Combobox>
     *     or was autocompleted as label for the selected value.
     *   - `selectedValue`, the value from the autocomplete options that the 
     *     user selected.
     */
    value: React.PropTypes.shape({
      inputValue: React.PropTypes.string,
      selectedValue: React.PropTypes.any
    }).isRequired,

    /**
     * The type of autocompletion behavior:
     *   - `menu` to display a popup menu with autocompletion options.
     *   - `inline` to display the first autocompletion option as text 
     *      "typed ahead" of the user's input.
     *   - `both` to display both at once.
     * Default is `both`.
     */
    autocomplete: React.PropTypes.oneOf(["menu", "inline", "both"]),

    /**
     * Event handler fired when `value.selectedValue` changes to a new 
     * non-`null` value. Function called is passed `value.selectedValue`.
     */
    onSelect: React.PropTypes.func,

    /**
     * Function that takes an `option` value, and returns a string label.
     * Default is a function that coerces the `option` to a string.
     */
    getLabelForOption: React.PropTypes.func,

    /**
     * The component to render for the popup.
     * Default is `ListPopup`.
     */
    popupComponent: React.PropTypes.func,

    /**
     * The component to render for the input.
     * Default is `TypeaheadInput`.
     */
    inputComponent: React.PropTypes.func
  },

  getDefaultProps: function getDefaultProps() {
    return {
      autocomplete: "both",
      onSelect: emptyFunction,
      getLabelForOption: function (option) {
        return option + "";
      },
      popupComponent: ListPopup,
      inputComponent: TypeaheadInput
    };
  },

  getInitialState: function getInitialState() {
    return {
      id: getUniqueId("Combobox"),
      isOpen: false,
      options: [],
      optionIndex: null
    };
  },

  isInlineCompleting: function isInlineCompleting() {
    return ["inline", "both"].indexOf(this.props.autocomplete) !== -1;
  },

  getDescendantIdForOption: function getDescendantIdForOption(idx) {
    return idx !== null ? "" + this.state.id + "-" + idx : null;
  },

  getMenuIsOpen: function getMenuIsOpen() {
    var isMenuCompleting = ["menu", "both"].indexOf(this.props.autocomplete) !== -1;

    return this.state.isOpen && isMenuCompleting;
  },

  getInputTypeaheadValue: function getInputTypeaheadValue() {
    var _state = this.state;
    var options = _state.options;
    var optionIndex = _state.optionIndex;

    if (!this.isInlineCompleting() || optionIndex === null) {
      return null;
    }

    return this.props.getLabelForOption(options[optionIndex]);
  },

  updateOptionsForInputValue: function updateOptionsForInputValue(inputValue) {
    var _this = this;

    var optionsPromise = this.optionsPromise = this.props.getOptionsForInputValue(inputValue);

    optionsPromise.then(function (options) {
      // It's possible that when we're fetching, we may get out-of-order
      // promise resolutions, even for cases like a contrived setTimeout demo.
      // This leads to really wonky behavior.
      //
      // Ensure that we only update the state based on the most recent promise
      // that was started for fetching.

      if (_this.optionsPromise !== optionsPromise) {
        return;
      }

      _this.setState({
        isOpen: options.length > 0,
        options: options,
        optionIndex: _this.isInlineCompleting() && options.length ? 0 : null
      });
    });
  },

  handleInputChange: function handleInputChange(event) {
    var inputValue = event.target.value;

    this.setState({ optionIndex: null });
    this.updateOptionsForInputValue(inputValue);
    this.props.onChange({
      inputValue: inputValue,
      selectedValue: null
    });
  },

  handleListChange: function handleListChange(optionIndex) {
    this.setState({ optionIndex: optionIndex });
  },

  handleComplete: function handleComplete() {
    this.setState({ isOpen: false });

    if (this.state.optionIndex !== null) {
      var option = this.state.options[this.state.optionIndex];

      this.setState({ optionIndex: null });
      this.props.onSelect(option);
      this.props.onChange({
        inputValue: this.props.getLabelForOption(option),
        selectedValue: option
      });
    }
  },

  handleCancel: function handleCancel() {
    this.setState({ optionIndex: null, isOpen: false });
  },

  renderPopup: function renderPopup() {
    var PopupComponent = this.props.popupComponent;

    return React.createElement(PopupComponent, {
      options: this.state.options,
      optionIndex: this.state.optionIndex,
      onChange: this.handleListChange,
      onComplete: this.handleComplete,
      getLabelForOption: this.props.getLabelForOption,
      getDescendantIdForOption: this.getDescendantIdForOption
    });
  },

  render: function render() {
    var InputComponent = this.props.inputComponent;
    var _state = this.state;
    var isOpen = _state.isOpen;
    var optionIndex = _state.optionIndex;
    var options = _state.options;
    var _props = this.props;
    var autocomplete = _props.autocomplete;

    var otherProps = _objectWithoutProperties(_props, ["autocomplete"]);

    return React.createElement(
      InputPopupWrapper,
      {
        isOpen: this.getMenuIsOpen(),
        popupElement: this.renderPopup() },
      React.createElement(
        ListKeyBindings,
        {
          optionsLength: options.length,
          optionIndex: optionIndex,
          onChange: this.handleListChange,
          onComplete: this.handleComplete,
          onCancel: this.handleCancel },
        React.createElement(InputComponent, _extends({}, otherProps, {
          "aria-activedescendant": this.getDescendantIdForOption(optionIndex),
          "aria-autocomplete": this.props.autocomplete,
          typeaheadValue: this.getInputTypeaheadValue(),
          value: this.props.value.inputValue,
          onChange: this.handleInputChange,
          onBlur: this.handleComplete
        }))
      )
    );
  }

});

module.exports = Combobox;