"use strict";

var _defineProperty = function (obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); };

var React = require("react/addons");

var _React$addons = React.addons;
var cloneWithProps = _React$addons.cloneWithProps;
var PureRenderMixin = _React$addons.PureRenderMixin;

var emptyFunction = require("./helpers/emptyFunction");

var KEY_ARROW_DOWN = 40;
var KEY_ARROW_UP = 38;
var KEY_RETURN = 13;
var KEY_ESC = 27;

/**
 * <ListKeyBindings> represents the types of key behavior that should be used
 * to navigate between the different sequential items in <ListPopup>.
 */
var ListKeyBindings = React.createClass({
  displayName: "ListKeyBindings",

  mixins: [PureRenderMixin],

  propTypes: {
    /**
     * Event handler for when the user requests for the <ListPopup> to focus on
     * a different index. Function receives the `index` of the option to focus.
     */
    onChange: React.PropTypes.func.isRequired,

    /**
     * Event handler for when the user requests for the <ListPopup> to fill in
     * the parent <Combobox> widget. Function receives the `index` of the
     * option to focus.
     */
    onComplete: React.PropTypes.func.isRequired,

    /**
     * Event handler for when the user requests to cancel the autocompletion 
     * process and hide the <ListPopup>.
     */
    onCancel: React.PropTypes.func.isRequired,

    /**
     * The currently focused index of the affiliated <ListPopup>.
     */
    optionIndex: React.PropTypes.number,

    /**
     * The number of options in the affiliated <ListPopup>.
     */
    optionsLength: React.PropTypes.number
  },

  getDefaultProps: function getDefaultProps() {
    return {
      optionIndex: null,
      optionsLength: 0
    };
  },

  getKeyBindings: function getKeyBindings() {
    var _this = this;

    return (function () {
      var _ref = {};

      _defineProperty(_ref, KEY_ARROW_DOWN, _this.changeToNext);

      _defineProperty(_ref, KEY_ARROW_UP, _this.changeToPrevious);

      _defineProperty(_ref, KEY_RETURN, _this.complete);

      _defineProperty(_ref, KEY_ESC, _this.props.onCancel);

      return _ref;
    })();
  },

  isCompletionPossible: function isCompletionPossible() {
    return this.props.optionsLength > 0;
  },

  complete: function complete() {
    var _props = this.props;
    var optionIndex = _props.optionIndex;
    var onComplete = _props.onComplete;

    this.isCompletionPossible() && onComplete(optionIndex);
  },

  changeToNext: function changeToNext() {
    var _props = this.props;
    var optionIndex = _props.optionIndex;
    var optionsLength = _props.optionsLength;
    var onChange = _props.onChange;

    this.isCompletionPossible() && onChange(optionIndex === null ? 0 : Math.min(optionIndex + 1, optionsLength - 1));
  },

  changeToPrevious: function changeToPrevious() {
    var _props = this.props;
    var optionIndex = _props.optionIndex;
    var optionsLength = _props.optionsLength;
    var onChange = _props.onChange;

    this.isCompletionPossible() && this.props.onChange(optionIndex === null ? optionsLength - 1 : Math.max(0, optionIndex - 1));
  },

  handleKeyDown: function handleKeyDown(event) {
    var binding = this.getKeyBindings()[event.keyCode];
    if (binding) {
      event.preventDefault();
      binding();
    }
  },

  render: function render() {
    return cloneWithProps(React.Children.only(this.props.children), {
      onKeyDown: this.handleKeyDown
    });
  }

});

module.exports = ListKeyBindings;